\section{Servidor Backend}
Para implementar el servidor Backend multithread, se utilizaron las mismas funciones base que en la versión mono, pero modificadas para poder ejecutar concurrentemente. Las diferencias a destacar son las siguientes.
\\
\\
En primer lugar, para poder crear los sockets a utilizar entre el servidor backend-multi y los distintos usuarios, se definió la variable MAX_JUGADORES, con un valor de 256, así como un arreglo socketfd_clientes de tamaño MAX_JUGADORES como reemplazo de la variable  socketfd_cliente.
También se definió otro arreglo thread de tipo pthread_t del mismo tamaño. Esto para poder aceptar las conexiones de cada usuario con su socket correspondiente, así como la creación de cada thread mediante la funcion pthread_create provista por la libreria. Los threads son llamados así, a ejecutar la función atendedor_de_jugador, como se hacia en la version de un unico thread. Las funciones auxiliares no sufrieron mayores modificaciones (excepto las relacionadas a lectura o escritura, que se mencionaran en el siguiente párrafo), ya que, o bien utilizan variables locales a cada thread, o variables globales que fueron protegidas.
\\
\\
En segundo lugar, para aquellas funciones donde se realiza una lectura  o escritura de un casillero en alguno de los tableros, se implementaron las funciones \emph{leerCasillero} y \emph{escribirCasillero}. Dichas funciones utilizan los locks correspondientes  implementados en RWLock.cpp antes y después de realizar operaciones de lectura o escritura. Esto ofrece una ventaja de diseño ya que encapsula el comportamiento de locking de cualquier lectura o escritura de datos. Esencialmente, lo que sucede es que cada vez que un thread desea realizar una lectura o escritura, se llama a la función correspondiente. Luego esta función se encargara de hacer un lock, ejecución de operación , y luego unlock, de lectura o escritura según sea el caso. \\
Notar que para el correcto funcionamiento de estas funciones se definió una matriz de locks, que representa el estado de bloqueo de cada posición de los tableros. Esta matriz es única, ya que no es necesario modelar situaciones en las que una posición esta bloqueada en un tablero y desbloqueada en otro, pues la abstracción pretendida es que se comporten como un solo tablero.\\
 En cuanto a las escrituras,  cuando un jugador coloca una letra en el durante la formación de una palabra, no puede colocarlas en posiciones donde haya palabras completas, o letras colocadas por otros jugadores, es decir, solo habrá escrituras si la posición estaba vacía. Con las lecturas pasa algo distinto, como se pueden realizar lecturas en simultaneo por parte de varios usuarios, tener una sola matriz de locks no cambia el comportamiento en el caso de las lecturas, respecto de una posible implementación con distintos locks para cada tablero. Un caso en el que si hay un ligero cambio de comportamiento, es aquel en el cual alguien esta escribiendo en un tablero mientras otros usuarios quieren leer en el otro. En ese caso los lectores deberán esperar a que se termine la escritura en el otro tablero. Aun así esto no es un problema ya que no se busca que haya escrituras y lecturas en simultaneo, y porque se pretende que el comportamiento refleje la abstracción de tablero único.\\
Dado que las lecturas y escrituras se realizan siempre de la forma descripta, todos los recursos(posiciones del tablero) se toman solo de a uno, y siempre se liberan luego, por lo cual no existe nunca una instancia de hold and wait, y el sistema esta libre de deadlock.\\ Además, por cuestiones relacionadas con la implementación de los locks, el sistema se encuentra también libre de inanición. Esto puede verse con mas detalle en la sección rwlock.
\\
\\

